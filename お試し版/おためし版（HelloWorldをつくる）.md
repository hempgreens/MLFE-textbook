# 手を動かして学ぶ！コンピュータアーキテクチャとアセンブリ言語プログラミングの基本　おためし版

## おためし版
これは、『コンピュータアーキテクチャとアセンブリ言語プログラミングの基本』のおためし版です。本書はレビューしてくれる方、もしくはとりあえずちょっと試してみたい方向けのものとなっています。座学的なものよりも手を動かすことを特徴としているのが本版の『コンピュータアーキテクチャとアセンブリ言語プログラミングの基本』ですが、おためし版の本書においては『ちょっと座学』→『要件定義』→『実装』を30分でやることを目標としています。  
それではよろしくお願いいたします。

### コンピュータアーキテクチャって何だ？
コンピュータアーキテクチャとはというのを説明する前に、それぞれの単語の意味について辞書からでも引いてみましょう。
`computer`の主な意味は電算機、コンピュータです。まあ皆さんが想像するああいう機械ですね、コンピュータって何だという話に踏み込むととんでもなく長くなってしまいそうなので、とりあえず理解としてはそれで大丈夫です。  
`architecture`の主な意味は建築学、建物、構造、構成のような意味があります。おそらく建物という意味が本来の言葉で、そこから構造とか構成って意味を持つようになったんでしょうね。

単語を調べました。それではコンピュータアーキテクチャとは何でしょう。そのまま訳するならコンピュータの構成、ということになります。コンピュータアーキテクチャというちょっと長めのカタカナで話すと難しそうに聞こえますが、ようはコンピュータ構成です。英語で言った方がかっこいいからこの言い方をしているんですかね、わかりませんけど。

それでは代表的なコンピュータアーキテクチャについて紹介いたしましょう。ノイマンアーキテクチャをご存じですか？ノイマンアーキテクチャとは、私たちの身の回りにあるコンピュータの多くの構成の元となっている基本的なコンピュータアーキテクチャです。ノイマンアーキテクチャの特徴は三つです。

1. プログラム可変内蔵方式
    - プログラムを内部のメモリに記憶させることで、プログラムの入力や変更が簡単に行える。

2. 逐次処理方式
    - 命令をメモリに順番に格納して原則上から順に実行していくこと。

3. 単一メモリ方式
    - プログラムとデータは同じメモリに格納されるということ。

知っている人からすれば「そうだね、ノイマンアーキテクチャだね」という感じ、知らない人からすれば「プログラムとかデータが内部のメモリに記憶されて、命令は順々に取り出されるなんて当然でしょ」と思うと思います。そう思うのは、私たちの身の回りのコンピュータのほとんどがノイマンアーキテクチャの考え方で構成されている証拠です。対する概念としてハーバードアーキテクチャというものがありますが、まあ今回は良いでしょう。以上の三つの特徴をとりあえずおさえてくださいね。

ノイマンアーキテクチャは基本構成として五つの装置を持ちます。

1. 演算装置
    - データの算術演算や論理演算を行う装置です。
    - 構成としては、算術論理演算装置や計算結果とかをためておく汎用レジスタ、状態を記憶するフラグレジスタなど。

2. 制御装置
    - 全ての装置を制御する装置です。
    - 構成としては、次の命令をアドレスを保持するプログラムカウンタ、実行する命令を保持する命令レジスタ、命令を解釈するデコーダなど。

3. 記憶装置
    - データやプログラムを記憶しておく装置です。
    - 構成としては、メモリやRAMと呼ばれる主記憶装置、ストレージやROMと呼ばれる補助記憶装置など。

4. 入力装置
    - プログラムやデータを主記憶装置に入力する装置です。
    - キーボードやマウス、カメラやマイクなど。

5. 出力装置
    - 処理したデータを出力する装置です。
    - ディスプレイやプリンタ、スピーカなど。

全て大切な要素なのですが、やはり注目したいのは演算装置と制御装置です。これらを一緒にして収めたのがCPUと呼ばれる部品です。ではCPUはどんな動作をするのでしょうか。CPUの命令実行の流れを理解する点で必要な段階は三つです。

1. 命令の取り出し（fetch）
    - プログラムカウンタの値を基に次の命令を主記憶から取り出し、命令レジスタに格納します。

2. 命令の解読（decode）
    - 命令レジスタには命令として0と1で構成されるビット列が格納されている訳ですが、それを基にデコーダが次に実行する命令を解読・各装置へ指示を出します。

3. 命令の実行（execution）
    - 解読した内容から算術論理演算装置や汎用レジスタなどで処理を実行させます。その結果によってフラグレジスタやプログラムカウンタの値が更新され、命令の取り出しが行われます。

専門用語をまくしたてました。完全に理解しなくても、まあコンピュータって五つの装置で構成されるんだなとか、命令実行はフェッチ・デコード・実行の流れで行われるのだなとなんとなく覚えておけば大丈夫です。

それでは次行ってみましょう。


### アセンブリ言語って何？
さっきの内容がハードウェアについての話だとしたら、この話はソフトウェアの話ということになります。アセンブリ言語の話をする前に、まずはプログラミング言語について話をしましょう。プログラミング言語には実行方式に着目して二種類あると言われています。

1. コンパイラ方式
    - コンパイラとは、入力された文字列、ソースコードを解析して、命令処理のためのビット列、バイトコードを出力するアプリケーションのことです。実行環境を用意して先のバイトコードから実行します。
    - C言語、Javaなど

2. インタプリタ方式
    - インタプリタとは、入力された文字列を解析して、逐次実行する方式です。
    - Python、Javascriptなど

PythonなどのインタプリタもC言語などのコンパイラ方式によって出力されています。つまりコンパイラを制すればインタプリタも制すということです。

話がちょっとそれました、今回着目するのは、コンパイラ方式の説明で現れたバイトコードと実行環境です。実行環境はわかりますね、コンピュータそのものです。バイトコードとは、命令やデータをビット列の形式で格納している状態のことで、この場合においては主記憶に乗るビット列の元となるもののことです。

そしてCPUで実行されるバイトコードのことを機械語と言います。この機械語を理解すればコンピュータを掌握したのも同然なのですが、01で記述されるものから何をしているのかを考えることは、オルゴールの譜面の穴を見ただけでどんな曲が記録されているのかを考えるようなもので、基本的には人間には困難です。  
この機械語と一対一で対応するものとして、アセンブリ言語があります。イメージで言うとこんな感じです。

<br>

|機械語|意味|アセンブリ言語|
|:---:|:-:|:-----:|
| 0001|アドレス番地01からレジスタへ値を読み込む|LD 01|
| 0110|レジスタの値を2増やす|ADD 2|
| 1001|レジスタの値が0だったときアドレス01の命令を実行する|JZE 01|
| 1100|レジスタの内容をアドレス番地11へ書き込む|ST 11|

左のような機械語を直接人間が操作するのは難しいので、右のようなアセンブリ言語の形式で記述して理解しようというものです。本シミュレータはアセンブリ言語の実行をするもので、アセンブリ言語をがしがし記述していくことによってハードウェアもソフトウェアも勉強しようというのが本学習環境の目標です。

### HelloWorldの要件定義
それではアセンブリ言語をがしがし書いていきますかね。今回はおためし版ということで、手始めにHelloWorldでも出力しましょうか。一応断っておくのですが、本書はC言語について基本的な知識を要求することをご了承ください。

それでは、HelloWorldの要件定義をしましょう、要件定義というと堅苦しいのですが、要はこのような条件でこのようなことがしたいですということが書かれているものです。

- HelloWorldという文字列を出力する
- MLFEに準じた環境で実行する
- HelloWorldという文字列を格納するために配列構造を実装する
- 繰り返し呼び出すためのループ構造を実装する
- 標準出力にて文字列を出力する

### MLFEについて
MLFEとはNABY（Newbee Architecture By Y）というCPUにて実行される命令セットのことです。NABYは32bitRISCアーキテクチャで設計されており、ワイヤードロジック方式・I/OマップドI/O方式を採用しています。

MLFEは基本情報技術者試験のCASL-2を拡張したもので、多くの仕様や命令セットを共有しています。

また専門用語をまくしたてましたね、ここは分かる人向けの記述で分からない人は分からなくても大丈夫です。ここで出現した専門用語に関してはおためし版では省略しますが本版ではきちんと紹介していますので興味があったら是非本版もやってみてください。

MLFEのアセンブリ言語は、基本的な構造として以下のような記述をします。

```
PGM     START
        RET
        END
```

`PGM`はラベルです。アドレス番地に名前を付けるような役割があります。  
`START`はプログラムのはじまりを宣言するアセンブラ命令です。このアドレスが最初にプログラムカウンタに入れられる感じですね。  
`END`はプログラムの終わりを知らせるアセンブラ命令です。  
アセンブラ命令とは、機械語とは違いプログラムの開始位置やデータ領域の確保など行う命令のことです。  
`RET`はC言語のreturnのように呼び出された所へ帰る命令ですが、今回の場合ではC言語のmain関数の最後の`return 0;`のようなものだと思ってください。

このソースコードを適当な名前で保存してmlfe.pyに通したら実行できます。このプログラムは何もしないので出力とかは特にありません。

```
> python mlfe.py test.fe

```

ファイル名は`test.fe`で保存してみました。拡張子は`.fe`としていますが、何でも大丈夫です。

### 出力
まず、どのように標準出力をすれば良いかが一番大切かもしれませんね。出力は主に`WRITE`命令にて行われます。

```
        WRITE   GR0, GR1
```

上の例では、レジスタ`GR0`が指すポートにレジスタ`GR1`の内容を書き込むという意味です。それぞれのポートにはどのような意味があるのかと言いますと、

|出力ポート番号|意味|
|::|::|
|0|標準文字出力|
|1|符号付き10進数出力|
|2|2進数出力|
|3|16進数出力|
|4|符号なし10進数出力|

例えば`GR0`に`0`が読み込まれていたら、`GR1`の値を文字と解釈して出力する、みたいな感じです。

```
PGM     START
        LD      GR1, VALUE
        LAD     GR0, 0      ; stdout_charactor
        WRITE   GR0, GR1
        CALL    LF
        
        LAD     GR0, 1      ; stdout_decimal
        WRITE   GR0, GR1
        CALL    LF
        
        LAD     GR0, 2      ; stdout_bin
        WRITE   GR0, GR1
        CALL    LF
        
        LAD     GR0, 3      ; stdout_hex
        WRITE   GR0, GR1
        CALL    LF
        
        LAD     GR0, 4      ; stdout_unsigned_decimal
        WRITE   GR0, GR1
        CALL    LF
        
        RET
VALUE   DC      '?'

; 改行処理
LF      OUT     ='\n', =1
        RET
        END
```

```
> python mlfe.py writetest.fe
?
63
3f
111111
63
```

この中では主に`0`と`1`を用いることになります。これからよく出るので覚えていてくださいね。

### 配列

ユーザには配列がある程度分かっている、とこちらは想定しているのですが、説明の都合一応解説させてくださいね。配列というのはあるデータを連続した領域に確保するデータ構造で、例えばC言語で言う`int型配列`のようなものを要件定義するとしたらこのようになります。

- 配列には添え字1つに1つの数値が対応している
- 配列の長さは固定長で、事前に長さを指定する
- アクセスには配列の先頭番地と添え字を使う
- 確保した領域に対して読み書きを行うことが出来る

MLFEにはデータを確保するときにはアセンブリ命令として`DC`を用います。

```
MSG     DC      'HelloWorld'
LEN     DC      10
```

MLFEは32bitが基本的な単位になっております。C言語のchar型は8bitですが、MLFEでは文字でも数値でも32bit固定長で扱います。上の`MSG`で確保した文字列は32bitの変数を10個もつ配列を定義したということです。

メモリからレジスタへ書き込みをするには`LD`命令を使います。`LD`命令には以下の形式があります。

```
        LD      GR1, MSG        ; GR1 <- Memory[MSG]
        LD      GR1, MSG, GR2   ; GR1 <- Memory[MSG + GR2]
```

上の方はレジスタ`GR1`にアドレス`MSG`の値を読み込み、つまり`H`が入ります。二つ目はレジスタ`GR1`にアドレス`MSG`と`GR2`の値を加算したものをアドレスとして扱い読み込みをします。

配列アクセスのような場合はどちらのアクセスの方が良いと思いますか？下ですよね。`GR2`を添え字のように扱うことで配列へ自由なアクセスをすることが出来ます。

ちなみに今回は使いませんが、メモリへ格納するには`ST`命令を使います。

```
        ST      GR1, MSG        ; GR1 -> Memory[MSG]
        ST      GR1, MSG, GR2   ; GR1 -> Memory[MSG + GR2]
```

以上を踏まえて、配列のアクセスはこのように実装することが出来ます。

```
PGM     START
        LD      GR2, SUB
        LD      GR1, MSG, GR2
        WRITE   GR0, GR1
        RET
MSG     DC      'HelloWorld'
SUB     DC      5
        END
```

上のソースコードを`arytest.fe`で保存して実行してみます。

```
> python mlfe.py arytest.fe
W
```

はい、きちんと5文字目の`W`が出力されましたね、`SUB`の所を数字を変えてみて変わるか試してくださいね。


### ループ構造
ループ構造についてですが、これも詳しくやると難しいのでいきなりソースコードを見せてしまいます。

```
PGM     START
        LD      GR0, STDOUTD    ; stdout_decimal
        LAD     GR1, 0          ; loop_counter
LOOP    CPA     GR1, LEN        ; if GR1 == LEN
        JZE     LOOPEND         ;   then goto LOOPEND
        WRITE   GR0, GR1        ; printf("%d", GR1)
        ADDA    GR1, ONE        ; GR1 += 1
        JUMP    LOOP            ; continue
LOOPEND RET

STDOUTD DC      1               ; "%d"
ONE     DC      1
LEN     DC      10

        END
```

とりあえず目新しいことを列挙します。

- 行末に`;`を書くことでそれ以降はコメントとして扱います。
- `CPA`命令は、比較する命令で`GR1`と`LEN`が等しかった時フラグレジスタの`ZF`が`1`になります。
- `JZE`命令は、`ZF`が`1`の時、指定されたアドレスへ移動する命令です。
- `ADDA`命令は、足し算をします。
- `JUMP`命令は、無条件で指定アドレスへ移動します。

つまり、`GR1`をループカウンタにしてインクリメントしていって`LEN`、つまり`10`と等しくなったらループ構造からぬけ`LOOPNED`の`RET`を実行、つまりプログラムが終了するという訳です。

```
> python mlfe.py looptest.fe
0123456789
```


### 実装
それでは実装していきます。まず必要なレジスタやメモリについて確認します。

|意味|割当|
|::|::|
|ポート番号|GR0|
|ループカウンタ|GR1|
|読み込んだ文字を保持|GR2|
|文字列|MSG|
|文字列長|LEN|
|ポート番号参照|STDOUT|
|ループカウンタの為の1|ONE|

```
PGM     START
        LD      GR0, STDOUT
        LAD     GR1, 0
        LAD     GR2, 0
        
LOOP    NOP                     ; 何もしないという命令、仮のもの
LOOPEND RET

MSG     DC      'HelloWorld'
LEN     DC      10
STDOUT  DC      0
ONE     DC      1

        END

```

ではループ構造と配列アクセスと標準出力を実装します。

```
; PGM省略
LOOP    CPA     GR1, LEN
        JZE     LOOPEND
        LD      GR2, MSG, GR1
        WRITE   GR0, GR2
        ADDA    GR1, ONE
        JUMP    LOOP
LOOPEND RET
; 変数省略
        END
```

完成しましたね。実行してみてください。

```
> python mlfe.py helloworld.fe
HelloWorld
```

まあ、HelloWorldくらいならマクロ命令を用いればとても簡単です。実際に標準出力がしたいときには`OUT`マクロ命令を使うと便利です。

```
PGM     START
        OUT     ='HelloWorld', =10
        RET
        END
```

マクロ命令とは、アセンブラによっていくつかの命令に展開されるショートカットのような命令、メモリ出力の`OUT`命令、乱数生成の`RANDINT`命令などがあります。

## まとめ

- コンピュータアーキテクチャとはコンピュータの構成のこと
- ノイマンアーキテクチャとは、以下の特徴を持つコンピュータアーキテクチャのことです。
    - プログラム可変内蔵
    - 逐次処理
    - 単一メモリ
- ノイマンアーキテクチャは`演算`・`制御`・`記憶`・`入力`・`出力`装置で構成される。
- 命令の実行は`フェッチ`・`デコード`・`実行`の流れで行われる。
- アセンブリ言語とは機械語と一対一対応させた人にやさしい機械語の表現。
- `HelloWorld`とはプログラミングを勉強するときにはじめてかくプログラムやその時に出力する文字列。
- `MLFE`はCASL-2を基に32bitRISCへ拡張した命令セット、およびそのシミュレータ。
- 出力は主に`WRITE`命令にて行われる。
- 配列の実装の為に、`DC`命令や`LD`命令を用いる。
- ループ構造の実装の為に、`CPA`命令や`JZE`命令を用いる。
- コメントは`;`と記述する。
- 連続した領域の出力にはマクロ命令の`OUT`命令を用いることができる。

## おつかれさまでした。
いかがでしたでしょうか。教科書の内容をまとまる程度に抜粋して１つにしてみました。教科書ではこのほかに、プログラムのオプションや計算機の実装・マインスイーパの実装を行ったりしますので、興味があったら是非どうぞ！  
ここまで30分ほどを想定して作っているのですが…できましたか？思ったよりも時間かかったらごめんなさい、わからんことあったら、添付のマニュアルを読んだりしてみてね。

ありがとうございました。本版にておまちしております。